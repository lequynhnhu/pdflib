/*
 * Copyright (C) 2009 Patrick Farrell  and R. Scott Eisenberg. All Rights reserved.
 *  based on code by Shyam Sivaraman from http://www.sourcecodesworld.com/source/show.asp?ScriptID=807
 */

package com.pfarrell.stat;


import com.pfarrell.crypto.SecRandom;
import java.util.ArrayList;
import java.util.List;
import org.apache.log4j.Logger;

/**
 * The <code>BasicClusterAnalysis</code> class is the entry point for constructing Cluster Analysis objects.
 * Each instance of BasicClusterAnalysis object is associated with one or more clusters,
 * and a List of DataPoint objects. The BasicClusterAnalysis and DataPoint classes are
 * the only classes available from other packages.
 * @see DataPoint
 * @author pfarrell
 * Created on Dec 24, 2009, 11:06:39 AM
 */
public class BasicClusterAnalysis {
     /** logger instance */
private static final Logger aLog = Logger.getLogger(BasicClusterAnalysis.class);
    private final SecRandom ranGen = SecRandom.getInstance();
    private Cluster[] clusters;
    /** how many tries */
    private int itersWanted;
    /** our copy of the data points */
    private ArrayList<DataPoint> allDataPoints = new ArrayList<DataPoint>();
    /** sum of the squares of the metric across all clusters */
    private double sumMetricSquared;

    /**
     * public constructor
     * @param k number of clusters to set
     * @param iter number of times to iterate
     * @param dataPoints List of datapoints
     */
    public BasicClusterAnalysis(int k, int iter, ArrayList<DataPoint> dataPoints) {
        clusters = new Cluster[k];
        for (int i = 0; i < k; i++) {
            clusters[i] = new Cluster("Cluster" + i);
        }
        itersWanted = iter;
        allDataPoints = dataPoints;
    }

    /**
     * start, assign points to clusters
     */
    public void setup() {
        setInitialCentroids();
        logClusters();
        for (DataPoint considerDP : allDataPoints) {
            Cluster best = assignPointToCluster(considerDP);
            best.addDataPoint(considerDP);
            aLog.trace(considerDP + " assigned to " + best.getCentroid().toString());
        }
        logClusters();
        assignment(0);
        logClusters();
    }
    private Cluster assignPointToCluster(DataPoint arg) {
        Cluster best = null;
        if (true) {
            best = randomAssignPoint(arg);
        } else {
            best = minDistanceAssignPoint(arg);
        }
        return best;
    }
    private Cluster randomAssignPoint(DataPoint arg) {
        int idx = ranGen.nextInt(clusters.length);
        return clusters[idx];
    }
    private Cluster minDistanceAssignPoint(DataPoint arg) {
        Cluster best = null;
        double minClusDist = Double.MAX_VALUE;
        for (Cluster working : clusters) {
            double tmp = arg.getEuclideanDistanceToClusterCentroid(working);
            if (tmp < minClusDist) {
                minClusDist = tmp;
                best = working;
            }
        }
        return best;
    }
    public void solve() {
        setup();
        int numNoChanges = 0;
        for (int i = 0; i < itersWanted; i++) {
            logClusters();
            boolean movedAny = assignment(i);
            if ( ! movedAny) {
                aLog.debug("no more changes at iter " + i);
                numNoChanges++;
                if (numNoChanges > 3)
                    break;
            } else numNoChanges = 0;
            updateMeans();
        }
    }
    private void logClusters() {
        aLog.debug("Number of clusters " + clusters.length);
        for (Cluster cl : clusters) {
            StringBuilder sb = new StringBuilder();
            sb.append(cl.getCentroid().getCx()).append(",");
            sb.append(cl.getCentroid().getCy());
            sb.append("[");
            for (DataPoint dp : cl.getDataPoints()) {
                sb.append(dp).append(",");
            }
            sb.append("]");
            aLog.debug(sb.toString());
        }
    }
   /**
    * Assign each observation to the cluster with the closest mean
    * (i.e. partition the observations according to the Voronoi diagram generated by the means).
    */
    public boolean assignment(int iter) {
        boolean moveAny = false;
        for (DataPoint considerDP : allDataPoints) {
            double shortestDist = Double.MAX_VALUE;
            Cluster bestFit = null;
            for (Cluster cl : clusters) {
                 double distance = considerDP.getEuclideanDistanceToClusterCentroid(cl);
                 if ( distance < shortestDist) {
                     bestFit = cl;
                     shortestDist = distance;
                 }
            }
            aLog.debug(String.format("%d, Point %s d: %g", iter, considerDP.getName(), shortestDist));
            Cluster old = considerDP.getCluster();
            if ( bestFit != old) {
                bestFit.addDataPoint(considerDP);
                old.removeDataPoint(considerDP);
                moveAny = true;
            }
        }
        return moveAny;
    }
   /**
    * recalculate Cluster centroids - Start of Step 2
    */
    public void updateMeans() {
        for (Cluster cl : clusters) {
            cl.calcCentroid();
        }
        calcWithinClusterSumSquares();   
    }
/**
 * calculate the sum of the Squares of the Metric across all clusters.
 * Essentially the error residual
 * @return calculated sum
 */
    private double calcWithinClusterSumSquares() {
        double temp = 0;
        for (Cluster cl : clusters) {
            temp = temp + cl.getSumOfSquares();
        }
        sumMetricSquared = temp;
        return sumMetricSquared;
    }
    /**
     * gets list of clusters, each entry in List is a list of DataPoints
     * @return  list of clusters, each entry in List is a list of DataPoints
     */
    public List<List<DataPoint>> getClusterOutput() {
        ArrayList<List<DataPoint>> points = new ArrayList<List<DataPoint>>();
        for (Cluster cl : clusters) {
            points.add(cl.getDataPoints());
        }
        return points;
    }

/**
 * kn = (round((max-min)/k)*n)+min where n is from 0 to (k-1).
 */
    private void setInitialCentroids() {
        List<DataPoint> corners = fivePoints();
        for (int i = 0; i < clusters.length; i++) {
            Centroid cent = clusters[i].getCentroid();
            cent.setPoint(corners.get(i));
            aLog.trace(i + " corner " + corners.get(i));
        }
    }
private static final int NW = 0;
private static final int NE = 1;
private static final int SE = 2;
private static final int SW = 3;
private static final int Center = 4;
private List<DataPoint> fivePoints() {
    List<DataPoint> rval = new ArrayList<DataPoint>(5);
    for(int i = 0; i < 5; i++) {
        rval.add(allDataPoints.get(0));
    }
    double sumX = 0;
    double sumY = 0;
    double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, maxX = Double.MIN_VALUE, maxY =Double.MIN_VALUE;
    for (DataPoint dp : allDataPoints) {
        sumX += dp.getX();
        sumY += dp.getY();
        if (dp.getX() < minX) minX = dp.getX();
        if (dp.getY() < minY) minY = dp.getY();
        if (dp.getX() > maxX) maxX = dp.getX();
        if (dp.getY() > maxY) maxY = dp.getY();
        aLog.debug(dp);
    }
    aLog.debug(String.format("minX: %g, maxX: %g", minX, maxX ));
    aLog.debug(String.format("minY: %g, maxY: %g", minY, maxY ));
    double meanX = sumX/allDataPoints.size();
    double meanY = sumY/allDataPoints.size();
    aLog.debug(String.format("meanX: %g, meanY: %g", meanX, meanY ));
    rval.set(NW, new DataPoint(minX, maxY, "NW"));
    rval.set(NE, new DataPoint(maxX, maxY, "NE"));
    rval.set(SW, new DataPoint(minX, minY, "SW"));
    rval.set(SE, new DataPoint(maxX, minY, "SE"));
    rval.set(Center, new DataPoint(meanX, meanY, "Center"));
    return rval;
}
    /**
     * gets number of clusters, really the K value from the constructor
     * @return number of clusters
     */
    public int getKValue() {
        return clusters.length;
    }

    /**
     * gets number of iterations, really value from constructor
     * @return number of iterations
     */
    public int getIterations() {
        return itersWanted;
    }

    /**
     * gets size of input stream, counts the points
     * @return size of our collection of points
     */
    public int getTotalDataPoints() {
        return allDataPoints.size();
    }

    /**
     * sum of the squares of the metric across all clusters
     * @return sum of the squares of the metric across all clusters
     */
    public double getSumSquredMetricAcrossCs() {
        return sumMetricSquared;
    }

    /**
     * gets the argument Cluster
     * @param pos position index
     * @return the cluster
     */
    public Cluster getCluster(int pos) {
        return clusters[pos];
    }
}
